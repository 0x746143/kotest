package io.kotest.engine.spec

import io.kotest.core.factory.DynamicTest
import io.kotest.core.factory.TestFactory
import io.kotest.core.spec.InlineCallbacks
import io.kotest.core.spec.InlineConfiguration
import io.kotest.core.Tag
import io.kotest.core.Tuple2
import io.kotest.core.extensions.Extension
import io.kotest.core.extensions.SpecExtension
import io.kotest.core.extensions.TestCaseExtension
import io.kotest.core.listeners.ProjectListener
import io.kotest.core.listeners.TestListener
import io.kotest.core.spec.AfterProject
import io.kotest.core.spec.AfterSpec
import io.kotest.core.spec.AroundSpecFn
import io.kotest.core.spec.AroundTestFn
import io.kotest.core.spec.BeforeSpec
import io.kotest.core.spec.FinalizeSpec
import io.kotest.core.spec.PrepareSpec
import io.kotest.core.spec.Spec
import io.kotest.core.spec.TestCaseExtensionFn
import io.kotest.core.test.AssertionMode
import io.kotest.core.test.TestCase
import io.kotest.core.test.TestCaseConfig
import io.kotest.core.test.TestResult
import io.kotest.engine.config.Project
import kotlin.reflect.KClass

/**
 * A test suite is an abstract container of tests.
 *
 * The concrete implementation of suites are [Spec]s and [TestFactoryConfiguration].
 */
abstract class TestSuite : InlineCallbacks, InlineConfiguration {

   /**
    * Config applied to each test case if not overridden per test case.
    * If left null, then defaults to the project config default.
    */
   var defaultTestConfig: TestCaseConfig? = null

   /**
    * Sets an assertion mode which is applied to every test.
    */
   var assertions: AssertionMode? = null

   /**
    * Contains the [Tag]s that will be applied to every test.
    */
   internal var _tags: Set<Tag> = emptySet()

   /**
    * Contains the [TestFactory] instances that have been included with this config.
    */
   internal var factories = emptyList<TestFactory>()

   // test listeners
   // using underscore name to avoid clash in JS compiler with existing methods
   internal var _listeners = emptyList<TestListener>()

   internal var _extensions = emptyList<Extension>()

   fun extension(f: TestCaseExtensionFn) {
      _extensions = _extensions + object : TestCaseExtension {
         override suspend fun intercept(testCase: TestCase, execute: suspend (TestCase) -> TestResult): TestResult {
            return f(Tuple2(testCase, execute))
         }
      }
   }

   fun aroundTest(aroundTestFn: AroundTestFn) {
      _extensions = _extensions + object : TestCaseExtension {
         override suspend fun intercept(testCase: TestCase, execute: suspend (TestCase) -> TestResult): TestResult {
            val f: suspend (TestCase) -> TestResult = { execute(it) }
            return aroundTestFn(Tuple2(testCase, f))
         }
      }
   }

   fun aroundSpec(aroundSpecFn: AroundSpecFn) {
      _extensions = _extensions + object : SpecExtension {
         override suspend fun intercept(spec: KClass<out Spec>, process: suspend () -> Unit) {
            aroundSpecFn(Tuple2(spec, process))
         }
      }
   }

   fun beforeSpec(f: BeforeSpec) {
      listener(object : TestListener {
         override suspend fun beforeSpec(spec: Spec) {
            f(spec)
         }
      })
   }

   fun afterSpec(f: AfterSpec) {
      listener(object : TestListener {
         override suspend fun afterSpec(spec: Spec) {
            f(spec)
         }
      })
   }

   @Deprecated(
      "Cannot use inline version of prepare spec since this must run before the spec is created",
      level = DeprecationLevel.ERROR
   )
   fun prepareSpec(f: PrepareSpec) {
      listeners(object : TestListener {
         override suspend fun prepareSpec(kclass: KClass<out Spec>) {
            f(kclass)
         }
      })
   }

   /**
    * Registers a callback that will execute after all tests in this spec have completed.
    * This is a convenience method for creating a [TestListener] and registering it to only
    * fire for this spec.
    */
   fun finalizeSpec(f: FinalizeSpec) {
      Project.registerListener(object : TestListener {
         override suspend fun finalizeSpec(kclass: KClass<out Spec>, results: Map<TestCase, TestResult>) {
            if (kclass == this@TestSuite::class) {
               f(Tuple2(kclass, results))
            }
         }
      })
   }

   /**
    * Registers a callback that will execute after all specs have completed.
    * This is a convenience method for creating a [ProjectListener] and registering it.
    */
   fun afterProject(f: AfterProject) {
      Project.registerListener(object : ProjectListener {
         override suspend fun afterProject() {
            f()
         }
      })
   }

   /**
    * Adds [Tag]s to this factory, which will be applied to each test case generated by
    * this [TestFactoryConfiguration]. When this factory is included in a [Spec], only the tests generated
    * from this factory will have these tags applied.
    */
   override fun tags(vararg tags: Tag) {
      this._tags = this._tags + tags.toSet()
   }

   override fun <T : TestListener> listener(listener: T): T {
      listeners(listener)
      return listener
   }

   override fun listeners(vararg listener: TestListener) {
      this._listeners = this._listeners + listener.toList()
   }

   override fun extensions(vararg extensions: TestCaseExtension) {
      this._extensions = this._extensions + extensions.toList()
   }

   /**
    * Include the tests from the given [TestFactory] in this configuration.
    */
   override fun include(factory: TestFactory) {
      factories = factories + factory
   }

   /**
    * Includes the tests from the given [TestFactory] with the root tests of the
    * factory given the prefix.
    */
   fun include(prefix: String, factory: TestFactory) {
      fun DynamicTest.addPrefix(): DynamicTest = copy(name = name.copy(name = "$prefix $name"))
      factories = factories + factory.copy(tests = factory.tests.map { it.addPrefix() })
   }

   internal var autoCloseables = emptyList<AutoCloseable>()
}
