package io.kotlintest.properties

import io.kotlintest.JavaRandoms
import java.io.File
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.lang.reflect.WildcardType
import java.math.BigInteger
import java.util.*

/** A shared random number generator. */
private val RANDOM = Random()

class BigIntegerGen(maxNumBits: Int) : Gen<BigInteger> {

  private val numBitsGen: Gen<Int> = Gen.choose(0, maxNumBits)

  override fun generate(max: Int): Iterable<BigInteger> {
    return numBitsGen.generate(max).map { it.toBigInteger() }
  }
}

/**
 * A Generator, or [Gen] is responsible for generating data
 * to be used in property testing. Each generator will
 * generate data for a specific type <T>.
 *
 * The idea behind property testing is the testing framework
 * will automatically test a range of different values,
 * including edge cases and random values. For this reason
 * the [Gen] interface returns an Iterable<T>, where the values
 * generated should include the most common areas of failure.
 *
 * For example, a generator for integers such include at the
 * very least, values like zero, minus 1, positive 1,
 * Integer.MAX_VALUE and Integer.MIN_VALUE. In other words, a
 * range of values most likely to cause bugs. In addition, the
 * generator is likely to provide a series of random values.
 *
 * The number of values generated by the [Gen] is bounded
 * by the max parameter to the generate method.
 * Note: Implementations are free to return fewer values -
 * for example when generating values of an enumeration,
 * you cannot return values than that exist - but the should
 * never exceed this value. To exceed the limit would mean
 * for the test methods with multiple inputs, the total
 * number of test iterations would go crazy.
 */
interface Gen<out T> {

  fun generate(max: Int): Iterable<T>

  companion object {

    fun bigInteger(maxNumBits: Int = 32): Gen<BigInteger> = BigIntegerGen(maxNumBits)

    /**
     * Returns a stream of values, where each value is an
     * Int between the given min and max.
     */
    fun choose(min: Int, max: Int): Gen<Int> {
      assert(min < max, { "min must be < max" })
      return object : Gen<Int> {
        override fun generate(maxSize: Int): Iterable<Int> {
          return List(maxSize, { JavaRandoms.internalNextInt(RANDOM, min, max) })
        }
      }
    }

    /**
     * Returns a stream of values, where each value is a
     * Long between the given min and max.
     */
    fun choose(min: Long, max: Long): Gen<Long> {
      assert(min < max, { "min must be < max" })
      return object : Gen<Long> {
        override fun generate(maxSize: Int): Iterable<Long> {
          return List(maxSize, {
            JavaRandoms.internalNextLong(RANDOM, min, max)
          })
        }
      }
    }

    /**
     * Adapts a list into a generator.
     */
    fun <T> from(values: List<T>): Gen<T> = object : Gen<T> {
      override fun generate(max: Int): Iterable<T> = values
    }

    /**
     * Returns a stream of values for each value
     * in the enum.
     */
    inline fun <reified T : Enum<T>> enum(): Gen<T> = object : Gen<T> {
      override fun generate(max: Int): Iterable<T> {
        return T::class.java.enumConstants.toList()
      }
    }

    /**
     * Returns a stream of values where each value is a random
     * printed string. In addition the empty string, a multi line string
     * and a UTF8 string is always included.
     */
    fun string(): Gen<String> = object : Gen<String> {
      val literals = listOf("", """\nabc\n123\n""", "\u006c\u0069b/\u0062\u002f\u006d\u0069nd/m\u0061x\u002e\u0070h\u0070")
      override fun generate(max: Int): Iterable<String> {
        return List(max, { nextPrintableString(RANDOM.nextInt(100)) }) + literals
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen [Int]. The values returned always include
     * the following edge cases: [-2, -1, 0, 1, 2, Int.MIN_VALUE, Int.MAX_VALUE]
     */
    fun int() = object : Gen<Int> {
      val literals = listOf(-2, -1, 0, 1, 2, Int.MIN_VALUE, Int.MAX_VALUE)
      override fun generate(max: Int): Iterable<Int> {
        return List(max, { Math.abs(RANDOM.nextInt()) }) + literals
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen positive value. The values returned always include
     * the following edge cases: [0, 1, 2, Int.MAX_VALUE]
     */
    fun positiveIntegers() = object : Gen<Int> {
      override fun generate(max: Int): Iterable<Int> {
        return List(max, { Math.abs(RANDOM.nextInt()) }) + listOf(0, 1, 2, Int.MAX_VALUE)
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen natural number. The values returned always include
     * the following edge cases: [1, 2, Int.MAX_VALUE]
     */
    fun nats() = object : Gen<Int> {
      override fun generate(max: Int): Iterable<Int> {
        return List(max, { Math.abs(RANDOM.nextInt()) }) + listOf(1, 2, Int.MAX_VALUE)
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen negative value. The values returned always include
     * the following edge cases: [0, -1, -2, Int.MIN_VALUE]
     */
    fun negativeIntegers() = object : Gen<Int> {
      override fun generate(max: Int): Iterable<Int> {
        return List(max, { -Math.abs(RANDOM.nextInt()) }) + listOf(0, -1, -2, Int.MIN_VALUE)
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen created File object. The file objects do not necessarily
     * exist on disk.
     */
    fun file() = object : Gen<File> {
      override fun generate(max: Int): Iterable<File> {
        return List(max, { File(nextPrintableString(RANDOM.nextInt(100))) })
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen long. The values returned always include
     * the following edge cases: [-2, -1, 0, 1, 2, Long.MIN_VALUE, Long.MAX_VALUE]
     */
    fun long() = object : Gen<Long> {
      override fun generate(max: Int): Iterable<Long> {
        return List(max, { Math.abs(RANDOM.nextLong()) }) + listOf(-2, -1, 0, 1, 2, Long.MIN_VALUE, Long.MAX_VALUE)
      }
    }

    /**
     * Returns both boolean values
     */
    fun bool() = object : Gen<Boolean> {
      override fun generate(max: Int): Iterable<Boolean> = listOf(true, false).take(max)
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen Double.
     */
    fun double() = object : Gen<Double> {
      override fun generate(max: Int): Iterable<Double> {
        return List(max, { RANDOM.nextDouble() }) + listOf(-2.0, -1.0, 0.0, 1.0, 2.0, Double.MIN_VALUE, Double.MAX_VALUE, Double.NEGATIVE_INFINITY, Double.NaN, Double.POSITIVE_INFINITY)
      }
    }

    /**
     * Returns a stream of values where each value is a randomly
     * chosen Float.
     */
    fun float() = object : Gen<Float> {
      override fun generate(max: Int): Iterable<Float> {
        return List(max, { RANDOM.nextFloat() }) + listOf(-2.0F, -1.0F, 0.0F, 1.0F, 2.0F, Float.MIN_VALUE, Float.MAX_VALUE, Float.NEGATIVE_INFINITY, Float.NaN, Float.POSITIVE_INFINITY)
      }
    }

    /**
     * Returns a stream of values, where each
     * value is generated from the given function
     */
    fun <T> create(fn: () -> T): Gen<T> = object : Gen<T> {
      override fun generate(max: Int): Iterable<T> {
        return List(max, { fn() })
      }
    }

    /**
     * Returns a stream of values, where each value is
     * a set of values generated by the given generator.
     */
    fun <T> set(gen: Gen<T>): Gen<Set<T>> = object : Gen<Set<T>> {
      override fun generate(max: Int): Iterable<Set<T>> {
        return List(max, { gen.generate(max).toSet() })
      }
    }

    /**
     * Returns a stream of values, where each value is
     * a list of values generated by the given generator.
     */
    fun <T> list(gen: Gen<T>): Gen<List<T>> = object : Gen<List<T>> {
      override fun generate(max: Int): Iterable<List<T>> {
        return List(max, { gen.generate(max).toList() })
      }
    }

    /**
     * Returns a stream of values, where each value is
     * a pair generated by the underlying generators.
     */
    fun <K, V> pair(genK: Gen<K>, genV: Gen<V>): Gen<Pair<K, V>> = object : Gen<Pair<K, V>> {
      override fun generate(max: Int): Iterable<Pair<K, V>> {
        return genK.generate(max).zip(genV.generate(max))
      }
    }

    // list(pair(genK, genV)).generate().toMap()

    /**
     * Returns a stream of values, where each value is
     * a Map, which contains keys and values generated
     * from the underlying generators.
     */
    fun <K, V> map(genK: Gen<K>, genV: Gen<V>): Gen<Map<K, V>> = object : Gen<Map<K, V>> {
      override fun generate(max: Int): Iterable<Map<K, V>> {
        return List(max, { genK.generate(max).zip(genV.generate(max)).toMap() })
      }
    }

    fun forClassName(className: String): Gen<*> {
      return when (className) {
        "java.lang.String" -> string()
        "kotlin.String" -> string()
        "java.lang.Integer" -> int()
        "kotlin.Int" -> int()
        "java.lang.Long" -> long()
        "kotlin.Long" -> long()
        "java.lang.Boolean" -> bool()
        "kotlin.Boolean" -> bool()
        "java.lang.Float" -> float()
        "kotlin.Float" -> float()
        "java.lang.Double" -> double()
        "kotlin.Double" -> double()
        else -> throw IllegalArgumentException("Cannot infer generator for $className; specify generators explicitly")
      }
    }

    @Suppress("UNCHECKED_CAST")
    inline fun <reified T> default(): Gen<T> {
      return when (T::class.qualifiedName) {
        List::class.qualifiedName -> {
          val type = object : TypeReference<T>() {}.type as ParameterizedType
          val first = type.actualTypeArguments.first() as WildcardType
          val upper = first.upperBounds.first() as Class<*>
          list(forClassName(upper.name)) as Gen<T>
        }
        Set::class.qualifiedName -> {
          val type = object : TypeReference<T>() {}.type as ParameterizedType
          val first = type.actualTypeArguments.first() as WildcardType
          val upper = first.upperBounds.first() as Class<*>
          set(forClassName(upper.name)) as Gen<T>
        }
        Pair::class.qualifiedName -> {
          val type = object : TypeReference<T>() {}.type as ParameterizedType
          val first = (type.actualTypeArguments[0] as WildcardType).upperBounds.first() as Class<*>
          val second = (type.actualTypeArguments[1] as WildcardType).upperBounds.first() as Class<*>
          pair(forClassName(first.name), forClassName(second.name)) as Gen<T>
        }
        Map::class.qualifiedName -> {
          val type = object : TypeReference<T>() {}.type as ParameterizedType
          //map key type can have or have not variance
          val first = if (type.actualTypeArguments[0] is Class<*>) {
            type.actualTypeArguments[0] as Class<*>
          } else {
            (type.actualTypeArguments[0] as WildcardType).upperBounds.first() as Class<*>
          }
          val second = (type.actualTypeArguments[1] as WildcardType).upperBounds.first() as Class<*>
          map(forClassName(first.name), forClassName(second.name)) as Gen<T>
        }
        else -> forClassName(T::class.qualifiedName!!) as Gen<T>
      }
    }
  }

  /**
   * Returns the next pseudorandom, uniformly distributed value
   * from the ASCII range 33-126.
   */
  private fun Random.nextPrintableChar(): Char {
    val low = 33
    val high = 127
    return (nextInt(high - low) + low).toChar()
  }

  fun nextPrintableString(length: Int): String {
    return (0 until length).map { RANDOM.nextPrintableChar() }.joinToString("")
  }
}

/**
 * A Generator which will return an iterable of a single given value.
 */
data class ConstGen<out T>(val value: T) : Gen<T> {
  override fun generate(max: Int): Iterable<T> = listOf(value)
}

/**
 * A [Gen] which will return the values from the underlying
 * generator plus null.
 */
fun <T> Gen<T>.orNull(): Gen<T?> {
  val t = this
  return object : Gen<T?> {
    val nullIterable = listOf(null)
    override fun generate(max: Int): Iterable<T?> = t.generate(max) + nullIterable
  }
}

/**
 * An extension function for [Gen] that filters values
 * from an underlying generator using a predicate function.
 */
@Deprecated("use gen.filter(T -> Boolean", ReplaceWith("generate().filter(isGood)"))
internal fun <T> Gen<T>.generateGood(isGood: (T) -> Boolean) = filter(isGood)

/**
 * A [Gen] which uses an extension function to filter
 * values from the underlying generator.
 */
fun <T> Gen<T>.filter(f: (T) -> Boolean): Gen<T> {
  val t = this
  return object : Gen<T> {
    override fun generate(max: Int): Iterable<T> = t.generate(max).filter(f)
  }
}

/**
 * An extension function for [Gen] that maps values
 * from an underlying generator using a mapper function.
 */
inline fun <A, B> Gen<A>.map(crossinline f: (A) -> B): Gen<B> {
  val t = this
  return object : Gen<B> {
    override fun generate(max: Int): Iterable<B> = t.generate(max).map(f)
  }
}

// need some supertype that types a type param so it gets baked into the class file
abstract class TypeReference<T> : Comparable<TypeReference<T>> {
  val type: Type = (javaClass.genericSuperclass as ParameterizedType).actualTypeArguments[0]
  override fun compareTo(other: TypeReference<T>) = 0
}
