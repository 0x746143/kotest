@file:Suppress("PropertyName")

package io.kotest.core.spec

import io.kotest.core.Tag
import io.kotest.core.config.Project
import io.kotest.core.listeners.ProjectListener
import io.kotest.core.extensions.TestCaseExtension
import io.kotest.core.factory.TestFactory
import io.kotest.core.factory.TestFactoryConfiguration
import io.kotest.core.listeners.TestListener
import io.kotest.core.runtime.configureRuntime
import io.kotest.core.runtime.executeSpec
import io.kotest.core.sourceRef
import io.kotest.core.test.*
import io.kotest.fp.Tuple2
import org.junit.platform.commons.annotation.Testable
import kotlin.reflect.KClass

typealias BeforeTest = suspend (TestCase) -> Unit
typealias AfterTest = suspend (Tuple2<TestCase, TestResult>) -> Unit
typealias BeforeSpec = () -> Unit
typealias AfterSpec = () -> Unit
typealias BeforeProject = () -> Unit
typealias AfterProject = () -> Unit
typealias PrepareSpec = (KClass<out Spec>) -> Unit
typealias FinalizeSpec = (Tuple2<KClass<out Spec>, Map<TestCase, TestResult>>) -> Unit
typealias TestCaseExtensionFn = suspend (
   testCase: TestCase,
   execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
   complete: suspend (TestResult) -> Unit
) -> Unit

typealias AroundTestFn = suspend (suspend (suspend (TestResult) -> Unit) -> Unit) -> Unit

expect interface AutoCloseable {
   fun close()
}

/**
 * The parent of all configuration DSL objects and contains configuration methods
 * common to both [Spec] and [TestFactoryConfiguration] implementations.
 */
abstract class TestConfiguration {

   /**
    * Config applied to each test case if not overridden per test case.
    * If left null, then defaults to the project config default.
    */
   var defaultTestConfig: TestCaseConfig? = null

   /**
    * Sets an assertion mode which is applied to every test.
    */
   var assertions: AssertionMode? = null

   /**
    * Contains the [Tag]s that will be applied to every test.
    */
   internal var _tags: Set<Tag> = emptySet()

   /**
    * Contains the [TestFactory] instances that have been included with this config.
    */
   internal var factories = emptyList<TestFactory>()

   // test lifecycle callbacks
   internal var beforeTests = emptyList<BeforeTest>()
   internal var afterTests = emptyList<AfterTest>()
   internal var beforeSpecs = emptyList<BeforeSpec>()
   internal var afterSpecs = emptyList<AfterSpec>()

   // test listeners
   // using underscore name to avoid clash in JS compiler with existing methods
   internal var _listeners = emptyList<TestListener>()
   internal var _extensions = emptyList<TestCaseExtension>()

   fun extension(f: TestCaseExtensionFn) {
      _extensions = _extensions + object : TestCaseExtension {
         override suspend fun intercept(
            testCase: TestCase,
            execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
            complete: suspend (TestResult) -> Unit
         ) {
            f(testCase, execute, complete)
         }
      }
   }

   fun aroundTest(runtest: AroundTestFn) {
      _extensions = _extensions + object : TestCaseExtension {
         override suspend fun intercept(
            testCase: TestCase,
            execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
            complete: suspend (TestResult) -> Unit
         ) {
            val f: suspend (suspend (TestResult) -> Unit) -> Unit = { callback ->
               execute(testCase) { result ->
                  callback(result)
                  complete(result)
               }
            }
            runtest.invoke(f)
         }
      }
   }

   /**
    * Registers a new before-test callback to be executed before every [TestCase] generated by
    * this [TestFactoryConfiguration]. The callback will only be executed for tests generated by this factory
    * and not other tests in a [Spec].
    */
   fun beforeTest(f: BeforeTest) {
      beforeTests = beforeTests + f
   }

   /**
    * Registers a new after-test callback to be executed after every [TestCase].
    * The callback provides two parameters - the test case that has just completed,
    * and the [TestResult] outcome of that test.  The callback will only be executed
    * for tests generated by this factory and not other tests in a [Spec].
    */
   fun afterTest(f: AfterTest) {
      afterTests = afterTests + f
   }

   fun beforeSpec(f: BeforeSpec) {
      beforeSpecs = beforeSpecs + f
   }

   fun afterSpec(f: AfterSpec) {
      afterSpecs = afterSpecs + f
   }

   fun prepareSpec(f: PrepareSpec) {
      listeners(object : TestListener {
         override fun prepareSpec(kclass: KClass<out Spec>) {
            f(kclass)
         }
      })
   }

   fun finalizeSpec(f: FinalizeSpec) {
      listeners(object : TestListener {
         override fun finalizeSpec(kclass: KClass<out Spec>, results: Map<TestCase, TestResult>) {
            f(Tuple2(kclass, results))
         }
      })
   }

   /**
    * Registers a callback that will execute after all specs have completed.
    * This is a convenience method for creating a [ProjectListener] and registering it.
    */
   fun afterProject(f: AfterProject) {
      Project.registerListener(object : ProjectListener {
         override fun afterProject() {
            f()
         }
      })
   }

   /**
    * Adds [Tag]s to this factory, which will be applied to each test case generated by
    * this [TestFactoryConfiguration]. When this factory is included in a [Spec], only the tests generated
    * from this factory will have these tags applied.
    */
   fun tags(vararg tags: Tag) {
      this._tags = this._tags + tags.toSet()
   }

   fun listener(listener: TestListener) {
      listeners(listener)
   }

   fun listeners(vararg listener: TestListener) {
      this._listeners = this._listeners + listener.toList()
   }

   fun extensions(vararg extensions: TestCaseExtension) {
      this._extensions = this._extensions + extensions.toList()
   }

   /**
    * Include the tests from the given [TestFactory] in this configuration.
    */
   fun include(factory: TestFactory) {
      factories = factories + factory
   }

   /**
    * Register an [AutoCloseable] so that it's close methods is automatically invoked
    * when the tests are completed.
    */
   fun <T : AutoCloseable> autoClose(closeable: T): T {
      afterSpecs = listOf({ closeable.close() }) + afterSpecs
      return closeable
   }
}

// we need to include setting the adapter as a top level val in here so that it runs before any suite/test in js
val initializeRuntime = configureRuntime()

@Testable
abstract class Spec : TestConfiguration(), SpecCallbackMethods {

   /**
    * Contains the root [TestCase]s used in this spec.
    */
   var rootTestCases = emptyList<TestCase>()

   /**
    * Sets the [IsolationMode] used by the test engine when running tests in this spec.
    * If left null, then the project default is applied.
    */
   var isolation: IsolationMode? = null

   /**
    * Sets the [TestCaseOrder] to control the order of execution of root level tests in this spec.
    * If left null, then the project default is applied.
    */
   var testOrder: TestCaseOrder? = null

   /**
    * The annotation [JsTest] is intercepted by the kotlin.js framework adapter to generate tests.
    *
    * We need to use this function to invoke the javascript test engine.
    *
    * Kotest automatically installs a Javascript test-adapter to intercept calls to all tests so we can
    * avoid passing this generating function to the underyling test framework so it doesn't appear
    * in the test report.
    */
   @JsTest
   fun javascriptTestInterceptor() {
      executeSpec(this)
   }

   private fun createTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ): TestCase {
      return TestCase(
         this::class.description().append(name),
         this,
         test,
         sourceRef(),
         type,
         config,
         null,
         null
      )
   }

   /**
    * Adds a new root-level [TestCase] to this [Spec].
    */
   protected fun addRootTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ) {
      require(rootTestCases.none { it.name == name }) { "Cannot add test with duplicate name $name" }
      require(name.isNotBlank() && name.isNotEmpty()) { "Cannot add test with blank or empty name" }
      //require(acceptingTopLevelRegistration) { "Cannot add nested test here. Please see documentation on testing styles for how to layout nested tests correctly" }
      rootTestCases = rootTestCases + createTestCase(name, test, config, type)
   }
}


