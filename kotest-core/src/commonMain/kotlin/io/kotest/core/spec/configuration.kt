package io.kotest.core.spec

import io.kotest.core.Tag
import io.kotest.core.extensions.SpecLevelExtension
import io.kotest.core.extensions.TestCaseExtension
import io.kotest.core.extensions.TestListener
import io.kotest.core.factory.TestFactory
import io.kotest.core.factory.TestFactoryConfiguration
import io.kotest.core.sourceRef
import io.kotest.core.test.*
import io.kotest.fp.Tuple2
import org.junit.platform.commons.annotation.Testable
import kotlin.reflect.KClass

typealias BeforeTest = suspend (TestCase) -> Unit
typealias AfterTest = suspend (Tuple2<TestCase, TestResult>) -> Unit
typealias BeforeSpec = () -> Unit
typealias AfterSpec = () -> Unit
typealias PrepareSpec = (KClass<out SpecConfiguration>) -> Unit
typealias FinalizeSpec = (Tuple2<KClass<out SpecConfiguration>, Map<TestCase, TestResult>>) -> Unit
typealias TestCaseExtensionFn = suspend (
   testCase: TestCase,
   execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
   complete: suspend (TestResult) -> Unit
) -> Unit

typealias AroundTestFn = suspend (suspend (suspend (TestResult) -> Unit) -> Unit) -> Unit

// these functions call out to the js test methods
// on the jvm these functions will be empty
expect fun generateTests(rootTests: List<TestCase>)

expect interface AutoCloseable {
   fun close()
}

/**
 * The parent of all configuration DSL objects and contains configuration methods
 * common to both [SpecConfiguration] and [TestFactoryConfiguration] implementations.
 */
abstract class TestConfiguration {

   /**
    * Config applied to each test case if not overridden per test case.
    * If left null, then defaults to the project config default.
    */
   var defaultTestCaseConfig: TestCaseConfig? = null

   /**
    * Sets an assertion mode which is applied to every test.
    */
   var assertionMode: AssertionMode? = null

   /**
    * Contains the [Tag]s that will be applied to every test.
    */
   var tags: Set<Tag> = emptySet()

   /**
    * Contains the [TestFactory] instances that have been included with this config.
    */
   var factories = emptyList<TestFactory>()

   // test lifecycle callbacks
   var beforeTests = emptyList<BeforeTest>()
   var afterTests = emptyList<AfterTest>()
   var beforeSpecs = emptyList<BeforeSpec>()
   var afterSpecs = emptyList<AfterSpec>()

   // test listeners
   var listeners = emptyList<TestListener>()
   var extensions = emptyList<SpecLevelExtension>()

   fun extension(f: TestCaseExtensionFn) {
      extensions = extensions + object : TestCaseExtension {
         override suspend fun intercept(
            testCase: TestCase,
            execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
            complete: suspend (TestResult) -> Unit
         ) {
            f(testCase, execute, complete)
         }
      }
   }

   fun aroundTest(runtest: AroundTestFn) {
      extensions = extensions + object : TestCaseExtension {
         override suspend fun intercept(
            testCase: TestCase,
            execute: suspend (TestCase, suspend (TestResult) -> Unit) -> Unit,
            complete: suspend (TestResult) -> Unit
         ) {
            val f: suspend (suspend (TestResult) -> Unit) -> Unit = { callback ->
               execute(testCase) { result ->
                  callback(result)
                  complete(result)
               }
            }
            runtest.invoke(f)
         }
      }
   }

   /**
    * Registers a new before-test callback to be executed before every [TestCase] generated by
    * this [TestFactoryConfiguration]. The callback will only be executed for tests generated by this factory
    * and not other tests in a [Spec].
    */
   fun beforeTest(f: BeforeTest) {
      beforeTests = beforeTests + f
   }

   /**
    * Registers a new after-test callback to be executed after every [TestCase].
    * The callback provides two parameters - the test case that has just completed,
    * and the [TestResult] outcome of that test.  The callback will only be executed
    * for tests generated by this factory and not other tests in a [Spec].
    */
   fun afterTest(f: AfterTest) {
      afterTests = afterTests + f
   }

   fun beforeSpec(f: BeforeSpec) {
      beforeSpecs = beforeSpecs + f
   }

   fun afterSpec(f: AfterSpec) {
      afterSpecs = afterSpecs + f
   }

   fun prepareSpec(f: PrepareSpec) {
      listeners(object : TestListener {
         override fun prepareSpec(kclass: KClass<out SpecConfiguration>) {
            f(kclass)
         }
      })
   }

   fun finalizeSpec(f: FinalizeSpec) {
      listeners(object : TestListener {
         override fun finalizeSpec(kclass: KClass<out SpecConfiguration>, results: Map<TestCase, TestResult>) {
            f(Tuple2(kclass, results))
         }
      })
   }

   /**
    * Adds [Tag]s to this factory, which will be applied to each test case generated by
    * this [TestFactoryConfiguration]. When this factory is included in a [Spec], only the tests generated
    * from this factory will have these tags applied.
    */
   fun tags(vararg tags: Tag) {
      this.tags = this.tags + tags.toSet()
   }

   fun listener(listener: TestListener) {
      listeners(listener)
   }

   fun listeners(vararg listener: TestListener) {
      this.listeners = this.listeners + listener.toList()
   }

   fun extensions(vararg extensions: SpecLevelExtension) {
      this.extensions = this.extensions + extensions.toList()
   }

   /**
    * Include the tests from the given [TestFactory] in this configuration.
    */
   fun include(factory: TestFactory) {
      factories = factories + factory
   }

   /**
    * Register an [AutoCloseable] so that it's close methods is automatically invoked
    * when the tests are completed.
    */
   fun <T : AutoCloseable> autoClose(closeable: T): T {
      afterSpecs = listOf({ closeable.close() }) + afterSpecs
      return closeable
   }
}

@Testable
abstract class SpecConfiguration : TestConfiguration(), CompatibilitySpecConfiguration {

   /**
    * Contains the root [TestCase]s used in this spec.
    */
   var rootTestCases = emptyList<TestCase>()

   /**
    * Sets the [IsolationMode] used by the test engine when running tests in this spec.
    * If left null, then the project default is applied.
    */
   var isolation: IsolationMode? = null

   /**
    * Sets the [TestCaseOrder] to control the order of execution of root level tests in this spec.
    * If left null, then the project default is applied.
    */
   var testOrder: TestCaseOrder? = null

   /**
    * This is a dummy method, intercepted by the kotlin.js framework adapter to generate tests.
    */
   @JsTest
   fun kotestGenerateTests() {
      generateTests(rootTestCases.toList())
   }

   private fun createTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ): TestCase {
      return TestCase(
         this::class.description().append(name),
         this,
         test,
         sourceRef(),
         type,
         config,
         null,
         null
      )
   }

   /**
    * Adds a new root-level [TestCase] to this [Spec].
    */
   protected fun addRootTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ) {
      require(rootTestCases.none { it.name == name }) { "Cannot add test with duplicate name $name" }
      require(name.isNotBlank() && name.isNotEmpty()) { "Cannot add test with blank or empty name" }
      //require(acceptingTopLevelRegistration) { "Cannot add nested test here. Please see documentation on testing styles for how to layout nested tests correctly" }
      rootTestCases = rootTestCases + createTestCase(name, test, config, type)
   }
}


