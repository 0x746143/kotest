package io.kotest.core.spec

import io.kotest.core.*
import io.kotest.core.factory.DynamicTest
import io.kotest.core.factory.TestFactory
import io.kotest.core.specs.AutoCloseable
import io.kotest.core.specs.JsTest
import io.kotest.core.specs.generateTests
import io.kotest.core.test.*
import io.kotest.extensions.SpecLevelExtension
import io.kotest.extensions.TestListener
import io.kotest.fp.Tuple2
import org.junit.platform.commons.annotation.Testable
import kotlin.reflect.KClass

typealias BeforeTest = suspend (TestCase) -> Unit
typealias AfterTest = suspend (Tuple2<TestCase, TestResult>) -> Unit
typealias BeforeSpec = () -> Unit
typealias AfterSpec = (Map<TestCase, TestResult>) -> Unit
typealias PrepareSpec = (KClass<out SpecConfiguration>) -> Unit
typealias FinalizeSpec = (Tuple2<KClass<out SpecConfiguration>, Map<TestCase, TestResult>>) -> Unit

/**
 * Builds an immutable [TestFactory] from this configuration.
 */
fun TestFactoryConfiguration.build(): TestFactory {

   val factory = TestFactory(
      tests = this.tests,
      tags = this.tags,
      listeners = this.listeners,
      extensions = this.extensions,
      assertionMode = this.assertionMode,
      factories = this.factories
   )

   val callbacks = object : TestListener {
      override suspend fun beforeTest(testCase: TestCase) {
         if (testCase.factory == factory) {
            this@build.beforeTests.forEach { it(testCase) }
         }
      }

      override suspend fun afterTest(testCase: TestCase, result: TestResult) {
         if (testCase.factory == factory) {
            this@build.afterTests.forEach { it(Tuple2(testCase, result)) }
         }
      }

      override fun afterSpec(spec: SpecConfiguration) {
         this@build.afterSpecs.forEach { it(emptyMap()) }
      }

      override fun beforeSpec(spec: SpecConfiguration) {
         this@build.beforeSpecs.forEach { it() }
      }
   }

   return factory.copy(listeners = listeners + callbacks)
}

/**
 * The parent of all configuration DSL objects and contains configuration methods
 * common to both [SpecConfiguration] and [TestFactoryConfiguration] implementations.
 */
abstract class TestConfiguration {

   /**
    * Config applied to each test case if not overridden per test case.
    */
   var defaultTestCaseConfig: TestCaseConfig =
      TestCaseConfig()

   /**
    * Sets an assertion mode which is applied to every test.
    */
   var assertionMode: AssertionMode? = null

   /**
    * Contains the [Tag]s that will be applied to every test.
    */
   var tags: Set<Tag> = emptySet()

   /**
    * Contains the [TestFactory] instances that have been included with this config.
    */
   var factories = emptyList<TestFactory>()

   // test lifecycle callbacks
   var beforeTests = emptyList<BeforeTest>()
   var afterTests = emptyList<AfterTest>()
   var beforeSpecs = emptyList<BeforeSpec>()
   var afterSpecs = emptyList<AfterSpec>()

   // test listeners
   var listeners = emptyList<TestListener>()
   var extensions = emptyList<SpecLevelExtension>()

   /**
    * Registers a new before-test callback to be executed before every [TestCase] generated by
    * this [TestFactoryConfiguration]. The callback will only be executed for tests generated by this factory
    * and not other tests in a [Spec].
    */
   fun beforeTest(f: BeforeTest) {
      beforeTests = beforeTests + f
   }

   /**
    * Registers a new after-test callback to be executed after every [TestCase].
    * The callback provides two parameters - the test case that has just completed,
    * and the [TestResult] outcome of that test.  The callback will only be executed
    * for tests generated by this factory and not other tests in a [Spec].
    */
   fun afterTest(f: AfterTest) {
      afterTests = afterTests + f
   }

   fun beforeSpec(f: BeforeSpec) {
      beforeSpecs = beforeSpecs + f
   }

   fun afterSpec(f: AfterSpec) {
      afterSpecs = afterSpecs + f
   }

   fun prepareSpec(f: PrepareSpec) {
      listeners(object : TestListener {
         override fun prepareSpec(kclass: KClass<out SpecConfiguration>) {
            f(kclass)
         }
      })
   }

   fun finalizeSpec(f: FinalizeSpec) {
      listeners(object : TestListener {
         override fun finalizeSpec(kclass: KClass<out SpecConfiguration>, results: Map<TestCase, TestResult>) {
            f(Tuple2(kclass, results))
         }
      })
   }

   /**
    * Adds [Tag]s to this factory, which will be applied to each test case generated by
    * this [TestFactoryConfiguration]. When this factory is included in a [Spec], only the tests generated
    * from this factory will have these tags applied.
    */
   fun tags(vararg tags: Tag) {
      this.tags = this.tags + tags.toSet()
   }

   fun listeners(vararg listener: TestListener) {
      this.listeners = this.listeners + listener.toList()
   }

   fun extensions(vararg extensions: SpecLevelExtension) {
      this.extensions = this.extensions + extensions.toList()
   }

   /**
    * Include the tests from the given [TestFactory] in this configuration.
    */
   fun include(factory: TestFactory) {
      factories = factories + factory
   }

   /**
    * Register an [AutoCloseable] so that it's close methods is automatically invoked
    * when the tests are completed.
    */
   fun <T : AutoCloseable> autoClose(closeable: T): T {
      afterSpecs = listOf<AfterSpec>({ closeable.close() }) + afterSpecs
      return closeable
   }
}

/**
 * A [TestFactoryConfiguration] provides a DSL to allow for easy creation of a
 * [TestFactory] when this class is the receiver of a lambda parameter.
 *
 * This class shouldn't be used directly, but as the base for a particular
 * layout style, eg [FunSpecTestFactoryConfiguration].
 */
abstract class TestFactoryConfiguration : TestConfiguration() {

   /**
    * Contains the [DynamicTest]s that have been added to this configuration.
    */
   internal var tests = emptyList<DynamicTest>()

   /**
    * Adds a new [DynamicTest] to this factory. When this factory is included into a [Spec]
    * these tests will be added to the spec as [TestCase]s.
    */
   protected fun addDynamicTest(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ) {
      require(tests.none { it.name == name }) { "Cannot add test with duplicate name $name" }
      require(name.isNotBlank() && name.isNotEmpty()) { "Cannot add test with blank or empty name" }
      this.tests = this.tests + DynamicTest(
         name,
         test,
         config,
         type,
         sourceRef()
      )
   }
}

@Suppress("DEPRECATION")
@Testable
abstract class SpecConfiguration : TestConfiguration(), CompatibilitySpecConfiguration {

   /**
    * Contains the root [TestCase]s used in this spec.
    */
   var rootTestCases = emptyList<TestCase>()

   /**
    * Sets the [IsolationMode] used by the test engine when running tests in this spec.
    * If left null, then the project default is applied.
    */
   var isolation: IsolationMode? = null

   /**
    * Sets the [TestCaseOrder] to control the order of execution of root level tests in this spec.
    * If left null, then the project default is applied.
    */
   var testOrder: TestCaseOrder? = null

   /**
    * This is a dummy method, intercepted by the kotlin.js framework adapter to generate tests.
    */
   @JsTest
   fun kotestGenerateTests() {
      generateTests(rootTestCases.toList())
   }

   private fun createTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ): TestCase {
      return TestCase(
         this::class.description().append(name),
         this,
         test,
         sourceRef(),
         type,
         config,
         null,
         null
      )
   }

   /**
    * Adds a new root-level [TestCase] to this [Spec].
    */
   protected fun addRootTestCase(
      name: String,
      test: suspend TestContext.() -> Unit,
      config: TestCaseConfig,
      type: TestType
   ) {
      require(rootTestCases.none { it.name == name }) { "Cannot add test with duplicate name $name" }
      require(name.isNotBlank() && name.isNotEmpty()) { "Cannot add test with blank or empty name" }
      //require(acceptingTopLevelRegistration) { "Cannot add nested test here. Please see documentation on testing styles for how to layout nested tests correctly" }
      rootTestCases = rootTestCases + createTestCase(name, test, config, type)
   }
}


